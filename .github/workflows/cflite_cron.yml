name: ClusterFuzzLite cron tasks
on:
  # For testing: trigger on push to feat/fuzz branch
  push:
    branches:
      - feat/fuzz
  schedule:
    # Run daily at midnight UTC
    - cron: '0 0 * * *'
  # Allow manual trigger
  workflow_dispatch:
    inputs:
      task:
        description: 'Task to run'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - prune
          - coverage

permissions:
  contents: read

# ==============================================================================
# Storage Repository Configuration for Organization
# ==============================================================================
# Required secrets/variables:
#   - Secret: CLUSTERFUZZLITE_STORAGE_TOKEN (PAT with repo write access)
#   - Variable: CLUSTERFUZZLITE_STORAGE_REPO (e.g., morph-l2/fuzz_corpora)
# ==============================================================================

env:
  STORAGE_REPO_URL: ${{ secrets.CLUSTERFUZZLITE_STORAGE_TOKEN && vars.CLUSTERFUZZLITE_STORAGE_REPO && format('https://{0}@github.com/{1}.git', secrets.CLUSTERFUZZLITE_STORAGE_TOKEN, vars.CLUSTERFUZZLITE_STORAGE_REPO) || '' }}
  STORAGE_REPO_BRANCH: main
  COVERAGE_BRANCH: coverage-reports

jobs:
  # ==============================================================================
  # Corpus Pruning - Removes redundant test cases from the corpus
  # ==============================================================================
  Pruning:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || github.event_name == 'schedule' || github.event.inputs.task == 'all' || github.event.inputs.task == 'prune' }}
    steps:
      - name: Build Fuzzers
        id: build
        uses: google/clusterfuzzlite/actions/build_fuzzers@v1
        with:
          language: go
          github-token: ${{ secrets.GITHUB_TOKEN }}
          sanitizer: address
          storage-repo: ${{ env.STORAGE_REPO_URL }}
          storage-repo-branch: ${{ env.STORAGE_REPO_BRANCH }}

      - name: Run Pruning
        id: run
        uses: google/clusterfuzzlite/actions/run_fuzzers@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          fuzz-seconds: 600
          mode: 'prune'
          sanitizer: address
          storage-repo: ${{ env.STORAGE_REPO_URL }}
          storage-repo-branch: ${{ env.STORAGE_REPO_BRANCH }}

  # ==============================================================================
  # Coverage Reports - Using Go native coverage with libFuzzer corpus conversion
  # ==============================================================================
  # Note: ClusterFuzzLite's coverage mode doesn't work with Go native fuzzers
  # due to corpus format incompatibility (Issue #13285). We use a custom approach:
  # 1. Download libFuzzer-format corpus from storage repo
  # 2. Convert to Go native fuzz format
  # 3. Run Go test with coverage using the converted corpus
  # 4. Generate HTML reports
  # ==============================================================================
  Coverage:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || github.event_name == 'schedule' || github.event.inputs.task == 'all' || github.event.inputs.task == 'coverage' }}
    needs: Pruning
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Download corpus from storage repo
        run: |
          echo "=== Cloning corpus repository ==="
          git clone --depth 1 --branch ${{ env.STORAGE_REPO_BRANCH }} \
            ${{ env.STORAGE_REPO_URL }} /tmp/fuzz_corpora || {
            echo "Failed to clone storage repo, continuing without corpus"
            mkdir -p /tmp/fuzz_corpora/corpus
          }
          echo "=== Corpus downloaded ==="
          ls -la /tmp/fuzz_corpora/corpus/ | head -20

      - name: Run coverage with corpus data
        run: |
          set -e
          mkdir -p coverage-reports

          # Define fuzzer mappings: fuzzer_name -> package_path:fuzz_function
          declare -A FUZZERS=(
            ["fuzz_abi"]="tests/fuzzers/abi:FuzzABI"
            ["fuzz_bitutil"]="tests/fuzzers/bitutil:FuzzBitutil"
            ["fuzz_difficulty"]="tests/fuzzers/difficulty:FuzzDifficulty"
            ["fuzz_keystore"]="tests/fuzzers/keystore:FuzzKeystore"
            ["fuzz_rlp"]="tests/fuzzers/rlp:FuzzRlp"
            ["fuzz_runtime"]="tests/fuzzers/runtime:FuzzRuntime"
            ["fuzz_trie"]="tests/fuzzers/trie:FuzzTrie"
            ["fuzz_stacktrie"]="tests/fuzzers/stacktrie:FuzzStacktrie"
            ["fuzz_rangeproof"]="tests/fuzzers/rangeproof:FuzzRangeproof"
            ["fuzz_txfetcher"]="tests/fuzzers/txfetcher:FuzzTxfetcher"
            ["fuzz_vflux_clientpool"]="tests/fuzzers/vflux:FuzzVfluxClientPool"
            ["fuzz_les"]="tests/fuzzers/les:FuzzLes"
            ["fuzz_bn256_add"]="tests/fuzzers/bn256:FuzzAdd"
            ["fuzz_bn256_mul"]="tests/fuzzers/bn256:FuzzMul"
            ["fuzz_bn256_pair"]="tests/fuzzers/bn256:FuzzPair"
            ["fuzz_secp256k1"]="tests/fuzzers/secp256k1:FuzzSecp256k1"
            ["fuzz_bls12381_g1_add"]="tests/fuzzers/bls12381:FuzzG1Add"
            ["fuzz_bls12381_g1_multiexp"]="tests/fuzzers/bls12381:FuzzG1MultiExp"
            ["fuzz_bls12381_g2_add"]="tests/fuzzers/bls12381:FuzzG2Add"
            ["fuzz_bls12381_g2_multiexp"]="tests/fuzzers/bls12381:FuzzG2MultiExp"
            ["fuzz_bls12381_pairing"]="tests/fuzzers/bls12381:FuzzPairing"
            ["fuzz_bls12381_map_g1"]="tests/fuzzers/bls12381:FuzzMapG1"
            ["fuzz_bls12381_map_g2"]="tests/fuzzers/bls12381:FuzzMapG2"
            ["fuzz_blake2b"]="crypto/blake2b:FuzzBlake2bF"
          )

          fuzzer_count=0

          for fuzzer_name in "${!FUZZERS[@]}"; do
            IFS=':' read -r pkg_path fuzz_func <<< "${FUZZERS[$fuzzer_name]}"
            corpus_dir="/tmp/fuzz_corpora/corpus/${fuzzer_name}"

            echo ""
            echo "============================================================"
            echo "Processing: $fuzzer_name ($fuzz_func in $pkg_path)"
            echo "============================================================"

            if [ ! -d "$corpus_dir" ]; then
              echo "No corpus found for $fuzzer_name, skipping"
              continue
            fi

            corpus_count=$(ls -1 "$corpus_dir" 2>/dev/null | wc -l)
            echo "Corpus contains $corpus_count files"

            if [ "$corpus_count" -eq 0 ]; then
              echo "Empty corpus, skipping"
              continue
            fi

            # Get package name from go.mod or directory
            pkg_name=$(basename "$pkg_path")

            # Create wrapper test file that reads corpus and calls fuzz function
            wrapper_file="./${pkg_path}/corpus_coverage_test.go"

            cat > "$wrapper_file" << GOEOF
          package ${pkg_name}

          import (
              "os"
              "path/filepath"
              "testing"
          )

          func TestCorpusCoverage(t *testing.T) {
              corpusDir := "${corpus_dir}"

              entries, err := os.ReadDir(corpusDir)
              if err != nil {
                  t.Skipf("Cannot read corpus dir: %v", err)
                  return
              }

              t.Logf("Running %d corpus files through ${fuzz_func}", len(entries))

              for _, entry := range entries {
                  if entry.IsDir() {
                      continue
                  }

                  filePath := filepath.Join(corpusDir, entry.Name())
                  data, err := os.ReadFile(filePath)
                  if err != nil {
                      t.Logf("Warning: cannot read %s: %v", entry.Name(), err)
                      continue
                  }

                  // Call the fuzz function with corpus data
                  // Use recover to catch panics (expected for some crash-inducing inputs)
                  func() {
                      defer func() {
                          if r := recover(); r != nil {
                              t.Logf("Panic on %s (expected for crash inputs): %v", entry.Name(), r)
                          }
                      }()
                      ${fuzz_func}(data)
                  }()
              }
          }
          GOEOF

            echo "Created wrapper test: $wrapper_file"

            # Run the wrapper test with coverage
            echo "Running coverage for $fuzz_func with corpus data..."
            cd "$pkg_path"

            if go test -v -cover -coverprofile="../../../coverage-reports/${fuzzer_name}.out" \
                -run="TestCorpusCoverage" . 2>&1 | tee "../../../coverage-reports/${fuzzer_name}.log"; then
              echo "Coverage completed for $fuzzer_name"
            else
              echo "Coverage failed for $fuzzer_name (some panics are expected)"
            fi

            cd - > /dev/null

            # Cleanup wrapper test
            rm -f "$wrapper_file"

            # Check if coverage file was generated
            if [ -f "coverage-reports/${fuzzer_name}.out" ]; then
              coverage=$(go tool cover -func="coverage-reports/${fuzzer_name}.out" 2>/dev/null | \
                grep total | awk '{print $3}' | tr -d '%' || echo "0")
              echo "Coverage for $fuzzer_name: ${coverage}%"
              ((fuzzer_count++)) || true
            fi
          done

          echo ""
          echo "============================================================"
          echo "Coverage Summary"
          echo "============================================================"
          echo "Processed $fuzzer_count fuzzers"

          # Generate HTML reports
          echo ""
          echo "Generating HTML reports..."
          for coverage_file in coverage-reports/*.out; do
            if [ -f "$coverage_file" ]; then
              name=$(basename "$coverage_file" .out)
              go tool cover -html="$coverage_file" -o="coverage-reports/${name}.html" 2>/dev/null || true
              echo "Generated: coverage-reports/${name}.html"
            fi
          done

          # Create summary report
          echo ""
          echo "Creating summary report..."
          cat > coverage-reports/index.html << 'HTMLEOF'
          <!DOCTYPE html>
          <html>
          <head>
            <title>Go-Ethereum Fuzzer Coverage Report</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 20px; }
              h1 { color: #333; }
              table { border-collapse: collapse; width: 100%; }
              th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
              th { background-color: #4CAF50; color: white; }
              tr:nth-child(even) { background-color: #f2f2f2; }
              a { color: #0066cc; }
              .high { background-color: #90EE90; }
              .medium { background-color: #FFE4B5; }
              .low { background-color: #FFB6C1; }
            </style>
          </head>
          <body>
            <h1>Go-Ethereum Fuzzer Coverage Report</h1>
            <p>Generated: $(date -u)</p>
            <p>Coverage is calculated by running corpus data through each fuzzer.</p>
            <table>
              <tr><th>Fuzzer</th><th>Coverage</th><th>Report</th></tr>
          HTMLEOF

          for coverage_file in coverage-reports/*.out; do
            if [ -f "$coverage_file" ]; then
              name=$(basename "$coverage_file" .out)
              cov=$(go tool cover -func="$coverage_file" 2>/dev/null | grep total | awk '{print $3}' || echo "N/A")
              echo "    <tr><td>${name}</td><td>${cov}</td><td><a href=\"${name}.html\">View</a></td></tr>" >> coverage-reports/index.html
            fi
          done

          cat >> coverage-reports/index.html << 'HTMLEOF2'
            </table>
          </body>
          </html>
          HTMLEOF2

          echo ""
          echo "=== Final coverage reports ==="
          ls -la coverage-reports/

      - name: Upload Coverage Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: go-coverage-report
          path: coverage-reports/
          retention-days: 30

      - name: Upload coverage to storage repository
        if: always() && env.STORAGE_REPO_URL != ''
        run: |
          if [ ! -d "coverage-reports" ] || [ -z "$(ls -A coverage-reports/*.html 2>/dev/null)" ]; then
            echo "No coverage reports to upload"
            exit 0
          fi

          echo "Uploading coverage reports to storage repo..."

          # Clone storage repo
          git clone --depth 1 --branch ${{ env.STORAGE_REPO_BRANCH }} \
            ${{ env.STORAGE_REPO_URL }} /tmp/fuzz_corpora

          # Create coverage directory with date
          DATE=$(date +%Y-%m-%d)
          COVERAGE_DIR="/tmp/fuzz_corpora/coverage/${DATE}"
          mkdir -p "$COVERAGE_DIR"

          # Copy coverage reports
          cp -r coverage-reports/* "$COVERAGE_DIR/"

          # Update latest symlink / copy
          rm -rf /tmp/fuzz_corpora/coverage/latest
          cp -r "$COVERAGE_DIR" /tmp/fuzz_corpora/coverage/latest

          # Create coverage index
          cat > /tmp/fuzz_corpora/coverage/README.md << 'EOF'
          # Fuzzer Coverage Reports

          Coverage reports are generated by running corpus data through each fuzzer.

          ## Latest Report

          See [latest/index.html](./latest/index.html)

          ## All Reports

          EOF

          # List all reports
          for dir in $(ls -d /tmp/fuzz_corpora/coverage/20*/ 2>/dev/null | sort -r | head -20); do
            date_dir=$(basename "$dir")
            echo "- [$date_dir](./$date_dir/index.html)" >> /tmp/fuzz_corpora/coverage/README.md
          done

          # Commit and push
          cd /tmp/fuzz_corpora
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "Add coverage report ${DATE} from ${{ github.repository }}" || echo "No changes to commit"
          git push || echo "Failed to push"

          echo "‚úÖ Coverage reports uploaded to storage repository"
          echo "üìÅ Location: coverage/${DATE}/"
