name: ClusterFuzzLite cron tasks
on:
  # For testing: trigger on push to feat/fuzz branch
  push:
    branches:
      - feat/fuzz
  schedule:
    # Run daily at midnight UTC
    - cron: '0 0 * * *'
  # Allow manual trigger
  workflow_dispatch:
    inputs:
      task:
        description: 'Task to run'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - prune
          - coverage

permissions:
  contents: read

# ==============================================================================
# Storage Repository Configuration for Organization
# ==============================================================================
# Required secrets/variables:
#   - Secret: CLUSTERFUZZLITE_STORAGE_TOKEN (PAT with repo write access)
#   - Variable: CLUSTERFUZZLITE_STORAGE_REPO (e.g., morph-l2/fuzz_corpora)
# ==============================================================================

env:
  STORAGE_REPO_URL: ${{ secrets.CLUSTERFUZZLITE_STORAGE_TOKEN && vars.CLUSTERFUZZLITE_STORAGE_REPO && format('https://{0}@github.com/{1}.git', secrets.CLUSTERFUZZLITE_STORAGE_TOKEN, vars.CLUSTERFUZZLITE_STORAGE_REPO) || '' }}
  STORAGE_REPO_BRANCH: main
  COVERAGE_BRANCH: coverage-reports

jobs:
  # ==============================================================================
  # Corpus Pruning - Removes redundant test cases from the corpus
  # ==============================================================================
  Pruning:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || github.event_name == 'schedule' || github.event.inputs.task == 'all' || github.event.inputs.task == 'prune' }}
    steps:
      - name: Build Fuzzers
        id: build
        uses: google/clusterfuzzlite/actions/build_fuzzers@v1
        with:
          language: go
          github-token: ${{ secrets.GITHUB_TOKEN }}
          sanitizer: address
          storage-repo: ${{ env.STORAGE_REPO_URL }}
          storage-repo-branch: ${{ env.STORAGE_REPO_BRANCH }}

      - name: Run Pruning
        id: run
        uses: google/clusterfuzzlite/actions/run_fuzzers@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          fuzz-seconds: 600
          mode: 'prune'
          sanitizer: address
          storage-repo: ${{ env.STORAGE_REPO_URL }}
          storage-repo-branch: ${{ env.STORAGE_REPO_BRANCH }}

  # ==============================================================================
  # Coverage Reports - Using Go native coverage with corpus conversion
  # ==============================================================================
  # Process:
  # 1. Download libFuzzer-format corpus from storage repo
  # 2. Convert to Go native fuzz format (testdata/fuzz directories) inline
  # 3. Run Go tests with coverage - fuzz functions will execute corpus as seed inputs
  # 4. Generate HTML coverage reports
  #
  # Key insight: Go 1.18+ automatically runs seed corpus from testdata/fuzz when
  # executing fuzz tests, even without -fuzz flag. This gives us corpus coverage.
  # ==============================================================================
  Coverage:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || github.event_name == 'schedule' || github.event.inputs.task == 'all' || github.event.inputs.task == 'coverage' }}
    needs: Pruning
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Download corpus from storage repo
        run: |
          echo "=== Cloning corpus repository ==="
          git clone --depth 1 --branch ${{ env.STORAGE_REPO_BRANCH }} \
            ${{ env.STORAGE_REPO_URL }} /tmp/fuzz_corpora || {
            echo "Failed to clone storage repo, continuing without corpus"
            mkdir -p /tmp/fuzz_corpora/corpus
          }
          echo "=== Corpus downloaded ==="
          ls -la /tmp/fuzz_corpora/corpus/ | head -20

      - name: Convert corpus to Go native format
        run: |
          echo "=== Converting ClusterFuzzLite corpus to Go native format ==="

          if [ ! -d "/tmp/fuzz_corpora/corpus" ]; then
            echo "No corpus directory found, skipping conversion"
            exit 0
          fi

          # Inline Python script for corpus conversion
          python3 << 'PYTHON_EOF'
          import os
          import sys
          from pathlib import Path

          # Fuzzer mapping: libFuzzer corpus name -> (Go package path, FuzzFunction name)
          FUZZER_MAP = {
              "fuzz_abi": ("tests/fuzzers/abi", "FuzzABI"),
              "fuzz_bitutil": ("tests/fuzzers/bitutil", "FuzzBitutil"),
              "fuzz_difficulty": ("tests/fuzzers/difficulty", "FuzzDifficulty"),
              "fuzz_keystore": ("tests/fuzzers/keystore", "FuzzKeystore"),
              "fuzz_rlp": ("tests/fuzzers/rlp", "FuzzRlp"),
              "fuzz_runtime": ("tests/fuzzers/runtime", "FuzzRuntime"),
              "fuzz_trie": ("tests/fuzzers/trie", "FuzzTrie"),
              "fuzz_stacktrie": ("tests/fuzzers/stacktrie", "FuzzStacktrie"),
              "fuzz_rangeproof": ("tests/fuzzers/rangeproof", "FuzzRangeproof"),
              "fuzz_txfetcher": ("tests/fuzzers/txfetcher", "FuzzTxfetcher"),
              "fuzz_vflux_clientpool": ("tests/fuzzers/vflux", "FuzzClientPool"),
              "fuzz_les": ("tests/fuzzers/les", "FuzzLes"),
              "fuzz_bn256_add": ("tests/fuzzers/bn256", "FuzzBn256Add"),
              "fuzz_bn256_mul": ("tests/fuzzers/bn256", "FuzzBn256Mul"),
              "fuzz_bn256_pair": ("tests/fuzzers/bn256", "FuzzBn256Pair"),
              "fuzz_secp256k1": ("tests/fuzzers/secp256k1", "FuzzSecp256k1"),
              "fuzz_bls12381_g1_add": ("tests/fuzzers/bls12381", "FuzzG1Add"),
              "fuzz_bls12381_g1_multiexp": ("tests/fuzzers/bls12381", "FuzzG1MultiExp"),
              "fuzz_bls12381_g2_add": ("tests/fuzzers/bls12381", "FuzzG2Add"),
              "fuzz_bls12381_g2_multiexp": ("tests/fuzzers/bls12381", "FuzzG2MultiExp"),
              "fuzz_bls12381_pairing": ("tests/fuzzers/bls12381", "FuzzPairing"),
              "fuzz_bls12381_map_g1": ("tests/fuzzers/bls12381", "FuzzMapG1"),
              "fuzz_bls12381_map_g2": ("tests/fuzzers/bls12381", "FuzzMapG2"),
          }

          def is_printable_ascii(data):
              """Check if data is printable ASCII."""
              if len(data) == 0:
                  return True
              try:
                  decoded = data.decode('ascii')
                  return all(32 <= ord(c) < 127 or c in '\t\n\r' for c in decoded)
              except:
                  return False

          def encode_bytes_for_go(data):
              """Encode bytes for Go native corpus format."""
              if len(data) == 0:
                  return '[]byte("")'

              if is_printable_ascii(data):
                  s = data.decode('ascii')
                  s = s.replace('\\', '\\\\')
                  s = s.replace('"', '\\"')
                  s = s.replace('\n', '\\n')
                  s = s.replace('\r', '\\r')
                  s = s.replace('\t', '\\t')
                  return f'[]byte("{s}")'

              hex_str = ''.join(f'\\x{b:02x}' for b in data)
              return f'[]byte("{hex_str}")'

          def convert_corpus_file(source_path, target_path):
              """Convert a single libFuzzer corpus file to Go native format."""
              try:
                  with open(source_path, 'rb') as f:
                      data = f.read()

                  target_path.parent.mkdir(parents=True, exist_ok=True)

                  with open(target_path, 'w', encoding='utf-8') as f:
                      f.write('go test fuzz v1\n')
                      f.write(encode_bytes_for_go(data) + '\n')

                  return True
              except Exception as e:
                  print(f"  Error converting {source_path.name}: {e}")
                  return False

          source_base = Path("/tmp/fuzz_corpora/corpus")
          target_base = Path(".")

          print("=" * 60)
          print("Converting ClusterFuzzLite corpus to Go native format")
          print("=" * 60)

          total_converted = 0
          total_fuzzers = 0

          for fuzzer_name, (pkg_path, fuzz_func) in sorted(FUZZER_MAP.items()):
              corpus_dir = source_base / fuzzer_name

              if not corpus_dir.exists():
                  continue

              corpus_files = [f for f in corpus_dir.iterdir() if f.is_file() and not f.name.startswith('.')]

              if not corpus_files:
                  continue

              print(f"‚Üí {fuzzer_name} -> {fuzz_func} ({len(corpus_files)} files)")

              target_dir = target_base / pkg_path / "testdata" / "fuzz" / fuzz_func

              converted = 0
              for corpus_file in corpus_files:
                  target_path = target_dir / corpus_file.name
                  if convert_corpus_file(corpus_file, target_path):
                      converted += 1

              print(f"  ‚úì Converted: {converted} files")
              total_converted += converted
              total_fuzzers += 1

          print("=" * 60)
          print(f"Total: {total_fuzzers} fuzzers, {total_converted} files converted")
          print("=" * 60)
          PYTHON_EOF

          echo ""
          echo "=== Checking generated testdata directories ==="
          find tests/fuzzers -type d -name "testdata" -exec sh -c 'echo "{}:"; find {} -type f | wc -l' \;

      - name: Run coverage for fuzzer packages
        run: |
          set -e
          mkdir -p coverage-reports

          # List of fuzzer packages to run coverage on
          FUZZER_PACKAGES=(
            "tests/fuzzers/abi"
            "tests/fuzzers/bitutil"
            "tests/fuzzers/difficulty"
            "tests/fuzzers/keystore"
            "tests/fuzzers/rlp"
            "tests/fuzzers/runtime"
            "tests/fuzzers/trie"
            "tests/fuzzers/stacktrie"
            "tests/fuzzers/rangeproof"
            "tests/fuzzers/txfetcher"
            "tests/fuzzers/vflux"
            "tests/fuzzers/les"
            "tests/fuzzers/bn256"
            "tests/fuzzers/secp256k1"
            "tests/fuzzers/bls12381"
          )

          fuzzer_count=0

          for pkg_path in "${FUZZER_PACKAGES[@]}"; do
            pkg_name=$(basename "$pkg_path")

            echo ""
            echo "============================================================"
            echo "Processing: $pkg_name ($pkg_path)"
            echo "============================================================"

            if [ ! -d "$pkg_path" ]; then
              echo "Package not found, skipping"
              continue
            fi

            # Check if testdata/fuzz exists (corpus available)
            if [ -d "$pkg_path/testdata/fuzz" ]; then
              corpus_count=$(find "$pkg_path/testdata/fuzz" -type f ! -name ".*" | wc -l | tr -d ' ')
              echo "Found testdata/fuzz with $corpus_count corpus files"
            else
              echo "No testdata/fuzz directory (will run tests without corpus)"
            fi

            # Run tests with coverage
            # Note: When testdata/fuzz exists, Go will automatically use it as seed corpus
            # The fuzz tests will run the corpus through the fuzz target
            echo "Running tests with coverage..."
            if go test -v -cover -coverprofile="coverage-reports/${pkg_name}.out" \
                "./${pkg_path}/..." 2>&1 | tee "coverage-reports/${pkg_name}.log"; then
              echo "Coverage completed for $pkg_name"
            else
              echo "Some tests failed for $pkg_name (may be expected)"
            fi

            # Check if coverage file was generated
            if [ -f "coverage-reports/${pkg_name}.out" ] && [ -s "coverage-reports/${pkg_name}.out" ]; then
              coverage=$(go tool cover -func="coverage-reports/${pkg_name}.out" 2>/dev/null | \
                grep total | awk '{print $3}' | tr -d '%' || echo "0")
              echo "Coverage for $pkg_name: ${coverage}%"
              ((fuzzer_count++)) || true
            fi
          done

          echo ""
          echo "============================================================"
          echo "Coverage Summary"
          echo "============================================================"
          echo "Processed $fuzzer_count packages"

          # Generate HTML reports
          echo ""
          echo "Generating HTML reports..."
          for coverage_file in coverage-reports/*.out; do
            if [ -f "$coverage_file" ] && [ -s "$coverage_file" ]; then
              name=$(basename "$coverage_file" .out)
              go tool cover -html="$coverage_file" -o="coverage-reports/${name}.html" 2>/dev/null || true
              echo "Generated: coverage-reports/${name}.html"
            fi
          done

          # Create summary report
          echo ""
          echo "Creating summary report..."
          cat > coverage-reports/index.html << 'HTMLEOF'
          <!DOCTYPE html>
          <html>
          <head>
            <title>Go-Ethereum Fuzzer Coverage Report</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 20px; }
              h1 { color: #333; }
              table { border-collapse: collapse; width: 100%; }
              th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
              th { background-color: #4CAF50; color: white; }
              tr:nth-child(even) { background-color: #f2f2f2; }
              a { color: #0066cc; }
            </style>
          </head>
          <body>
            <h1>Go-Ethereum Fuzzer Coverage Report</h1>
          HTMLEOF

          echo "    <p>Generated: $(date -u)</p>" >> coverage-reports/index.html
          echo "    <p>Coverage is calculated by running corpus data through each fuzzer package.</p>" >> coverage-reports/index.html
          echo "    <table>" >> coverage-reports/index.html
          echo "      <tr><th>Package</th><th>Coverage</th><th>Report</th></tr>" >> coverage-reports/index.html

          for coverage_file in coverage-reports/*.out; do
            if [ -f "$coverage_file" ] && [ -s "$coverage_file" ]; then
              name=$(basename "$coverage_file" .out)
              cov=$(go tool cover -func="$coverage_file" 2>/dev/null | grep total | awk '{print $3}' || echo "N/A")
              echo "      <tr><td>${name}</td><td>${cov}</td><td><a href=\"${name}.html\">View</a></td></tr>" >> coverage-reports/index.html
            fi
          done

          cat >> coverage-reports/index.html << 'HTMLEOF2'
            </table>
          </body>
          </html>
          HTMLEOF2

          echo ""
          echo "=== Final coverage reports ==="
          ls -la coverage-reports/

      - name: Upload Coverage Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: go-coverage-report
          path: coverage-reports/
          retention-days: 30

      - name: Upload coverage to storage repository
        if: always() && env.STORAGE_REPO_URL != ''
        run: |
          if [ ! -d "coverage-reports" ] || [ -z "$(ls -A coverage-reports/*.html 2>/dev/null)" ]; then
            echo "No coverage reports to upload"
            exit 0
          fi

          echo "Uploading coverage reports to storage repo..."

          # Clone storage repo
          git clone --depth 1 --branch ${{ env.STORAGE_REPO_BRANCH }} \
            ${{ env.STORAGE_REPO_URL }} /tmp/fuzz_corpora

          # Create coverage directory with date
          DATE=$(date +%Y-%m-%d)
          COVERAGE_DIR="/tmp/fuzz_corpora/coverage/${DATE}"
          mkdir -p "$COVERAGE_DIR"

          # Copy coverage reports
          cp -r coverage-reports/* "$COVERAGE_DIR/"

          # Update latest symlink / copy
          rm -rf /tmp/fuzz_corpora/coverage/latest
          cp -r "$COVERAGE_DIR" /tmp/fuzz_corpora/coverage/latest

          # Create coverage index
          cat > /tmp/fuzz_corpora/coverage/README.md << 'READMEEOF'
          # Fuzzer Coverage Reports

          Coverage reports are generated by running corpus data through each fuzzer.

          ## Latest Report

          See [latest/index.html](./latest/index.html)

          ## All Reports

          READMEEOF

          # List all reports
          for dir in $(ls -d /tmp/fuzz_corpora/coverage/20*/ 2>/dev/null | sort -r | head -20); do
            date_dir=$(basename "$dir")
            echo "- [$date_dir](./$date_dir/index.html)" >> /tmp/fuzz_corpora/coverage/README.md
          done

          # Commit and push
          cd /tmp/fuzz_corpora
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "Add coverage report ${DATE} from ${{ github.repository }}" || echo "No changes to commit"
          git push || echo "Failed to push"

          echo "‚úÖ Coverage reports uploaded to storage repository"
          echo "üìÅ Location: coverage/${DATE}/"
